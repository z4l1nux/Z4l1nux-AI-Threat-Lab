/**
 * Servi√ßo de Threat Modeling
 * Gerencia prompts, templates e l√≥gica de an√°lise de amea√ßas
 */

export interface ThreatModelingRequest {
  systemName: string;
  systemType: string;
  sensitivity: string;
  description: string;
  assets: string;
}

export interface Threat {
  id: string;
  stride: string[];
  categoria: string;
  ameaca: string;
  descricao: string;
  impacto: string;
  probabilidade: string;
  severidade: string;
  mitigacao: string;
  capec: string;
  deteccao: string;
}

export interface ThreatModelingResponse {
  threats: Threat[];
}

export class ThreatModelingService {
  private static readonly STRIDE_MAPPING = {
    'S': 'Falsifica√ß√£o de identidade, impersona√ß√£o, autentica√ß√£o comprometida',
    'T': 'Altera√ß√£o n√£o autorizada de dados, manipula√ß√£o de par√¢metros, integridade comprometida',
    'R': 'Nega√ß√£o de a√ß√µes, aus√™ncia de logs, impossibilidade de auditoria',
    'I': 'Exposi√ß√£o de dados sens√≠veis, vazamento de informa√ß√µes, logs mal configurados',
    'D': 'Sobrecarga do sistema, indisponibilidade, ataques de volume',
    'E': 'Escala√ß√£o de privil√©gios, bypass de controles, acesso administrativo n√£o autorizado'
  };

  private static readonly STRIDE_KEYWORDS = {
    'S': ['spoofing', 'impersonation', 'falsifica√ß√£o', 'identity', 'autentica√ß√£o', 'login'],
    'T': ['tampering', 'modification', 'altera√ß√£o', 'manipulation', 'manipula√ß√£o', 'integridade'],
    'R': ['repudiation', 'denial', 'nega√ß√£o', 'rep√∫dio', 'auditoria', 'logs'],
    'I': ['information', 'disclosure', 'exposi√ß√£o', 'vazamento', 'dados', 'sens√≠vel'],
    'D': ['denial', 'service', 'nega√ß√£o', 'servi√ßo', 'ddos', 'sobrecarga'],
    'E': ['elevation', 'privilege', 'escala√ß√£o', 'privil√©gio', 'administrativo', 'bypass']
  };

  private static readonly THREAT_KEYWORDS = [
    'vulnerabilidade', 'ataque', 'exploit', 'brecha', 'falha', 'risco',
    'comprometimento', 'invas√£o', 'penetra√ß√£o', 'bypass', 'bypassing',
    'unauthorized', 'n√£o autorizado', 'compromise', 'comprometer'
  ];

  /**
   * Gera o prompt principal para an√°lise de threat modeling
   */
  static generateThreatModelingPrompt(
    request: ThreatModelingRequest,
    baseConhecimento: string
  ): string {
    return `Voc√™ √© um especialista em Threat Modeling e An√°lise de Seguran√ßa. Sua tarefa √© analisar o sistema descrito e identificar amea√ßas de seguran√ßa espec√≠ficas baseadas na base de conhecimento fornecida.

SISTEMA A SER ANALISADO:
- Nome: ${request.systemName}
- Tipo: ${request.systemType}
- Sensibilidade: ${request.sensitivity}
- Descri√ß√£o: ${request.description}
- Ativos: ${request.assets}

INSTRU√á√ïES:
1. Analise o sistema descrito e identifique amea√ßas de seguran√ßa espec√≠ficas
2. Consulte especificamente o mapeamento STRIDE-CAPEC dispon√≠vel na base de conhecimento
3. Para cada amea√ßa identificada, use CAPECs REAIS da base de dados, n√£o invente c√≥digos CAPEC
4. Identifique amea√ßas espec√≠ficas baseadas nas tecnologias mencionadas na descri√ß√£o do sistema
5. Responda APENAS com um JSON v√°lido no formato especificado abaixo

MAPEAMENTO STRIDE OBRIGAT√ìRIO:
${Object.entries(this.STRIDE_MAPPING)
  .map(([key, value]) => `- ${key} (${this.getStrideName(key)}): ${value}`)
  .join('\n')}

IMPORTANTE: Uma amea√ßa pode ter M√öLTIPLAS categorias STRIDE. Use as categorias apropriadas baseadas no conte√∫do real da amea√ßa, n√£o force uma sequ√™ncia artificial.

FORMATO DE RESPOSTA (JSON):
{
  "threats": [
    {
      "id": "T001",
      "stride": ["S", "I"],
      "categoria": "Nome da categoria",
      "ameaca": "T√≠tulo da amea√ßa espec√≠fica para este sistema",
      "descricao": "Descri√ß√£o detalhada considerando as tecnologias espec√≠ficas do sistema",
      "impacto": "Descri√ß√£o do impacto no contexto deste sistema",
      "probabilidade": "Alta/M√©dia/Baixa",
      "severidade": "Cr√≠tica/Alta/M√©dia/Baixa", 
      "mitigacao": "Recomenda√ß√µes espec√≠ficas baseadas na arquitetura descrita",
      "capec": "CAPEC-XXX (usar apenas c√≥digos REAIS da base de conhecimento)",
      "deteccao": "Como detectar esta amea√ßa neste tipo de sistema"
    }
  ]
}

BASE DE CONHECIMENTO:
${baseConhecimento}`;
  }

  /**
   * Obt√©m o nome completo da categoria STRIDE
   */
  private static getStrideName(key: string): string {
    const names = {
      'S': 'Spoofing',
      'T': 'Tampering', 
      'R': 'Repudiation',
      'I': 'Information Disclosure',
      'D': 'Denial of Service',
      'E': 'Elevation of Privilege'
    };
    return names[key as keyof typeof names] || key;
  }

  /**
   * Gera amea√ßas mock para fallback
   */
  static getMockThreatsForSystem(systemType: string): Threat[] {
    const baseThreats: Threat[] = [
      {
        id: 'T001',
        stride: ['S', 'I'],
        categoria: 'Autentica√ß√£o',
        ameaca: 'Ataques de for√ßa bruta contra sistema de login',
        descricao: 'Atacantes podem tentar quebrar senhas atrav√©s de ataques automatizados de for√ßa bruta',
        impacto: 'Comprometimento de contas de usu√°rios e acesso n√£o autorizado ao sistema',
        probabilidade: 'M√©dia',
        severidade: 'Alta',
        mitigacao: 'Implementar bloqueio de conta ap√≥s tentativas falhidas, CAPTCHA, autentica√ß√£o multifator',
        capec: 'CAPEC-16, CAPEC-49',
        deteccao: 'Monitoramento de tentativas de login falhidas consecutivas'
      },
      {
        id: 'T002',
        stride: ['T', 'E'],
        categoria: 'Integridade de Dados',
        ameaca: 'Manipula√ß√£o de par√¢metros de requisi√ß√£o',
        descricao: 'Modifica√ß√£o n√£o autorizada de par√¢metros HTTP para alterar comportamento da aplica√ß√£o',
        impacto: 'Altera√ß√£o n√£o autorizada de dados ou bypass de controles de seguran√ßa',
        probabilidade: 'Alta',
        severidade: 'M√©dia',
        mitigacao: 'Valida√ß√£o robusta de entrada, assinatura de tokens, controle de integridade',
        capec: 'CAPEC-137, CAPEC-160',
        deteccao: 'Monitoramento de anomalias em par√¢metros de requisi√ß√£o'
      },
      {
        id: 'T003',
        stride: ['I', 'R'],
        categoria: 'Exposi√ß√£o de Dados',
        ameaca: 'Vazamento de informa√ß√µes atrav√©s de logs',
        descricao: 'Dados sens√≠veis podem ser expostos atrav√©s de logs de sistema mal configurados',
        impacto: 'Exposi√ß√£o de informa√ß√µes confidenciais e dados pessoais',
        probabilidade: 'M√©dia',
        severidade: 'M√©dia',
        mitigacao: 'Configura√ß√£o adequada de logs, sanitiza√ß√£o de dados sens√≠veis, controle de acesso aos logs',
        capec: 'CAPEC-117, CAPEC-204',
        deteccao: 'Auditoria regular dos logs e configura√ß√µes de logging'
      },
      {
        id: 'T004',
        stride: ['D'],
        categoria: 'Nega√ß√£o de Servi√ßo',
        ameaca: 'Ataques de DDoS na camada de aplica√ß√£o',
        descricao: 'Sobrecarga intencional do sistema atrav√©s de requisi√ß√µes maliciosas',
        impacto: 'Indisponibilidade do servi√ßo e degrada√ß√£o da performance',
        probabilidade: 'Alta',
        severidade: 'Alta',
        mitigacao: 'Rate limiting, WAF, CDN, monitoramento de tr√°fego',
        capec: 'CAPEC-125, CAPEC-130',
        deteccao: 'Monitoramento de m√©tricas de performance e padr√µes de tr√°fego'
      },
      {
        id: 'T005',
        stride: ['E', 'S'],
        categoria: 'Escala√ß√£o de Privil√©gios',
        ameaca: 'Explora√ß√£o de vulnerabilidades para eleva√ß√£o de privil√©gios',
        descricao: 'Atacantes podem explorar falhas de configura√ß√£o para obter acesso administrativo',
        impacto: 'Acesso n√£o autorizado a funcionalidades cr√≠ticas do sistema',
        probabilidade: 'Baixa',
        severidade: 'Cr√≠tica',
        mitigacao: 'Princ√≠pio do menor privil√©gio, auditoria de permiss√µes, monitoramento de atividades administrativas',
        capec: 'CAPEC-233, CAPEC-250',
        deteccao: 'Monitoramento de tentativas de escala√ß√£o de privil√©gios'
      },
      {
        id: 'T006',
        stride: ['R', 'T'],
        categoria: 'Rep√∫dio de Transa√ß√µes',
        ameaca: 'Manipula√ß√£o de logs para negar transa√ß√µes',
        descricao: 'Altera√ß√£o maliciosa de logs para esconder atividades fraudulentas',
        impacto: 'Incapacidade de comprovar transa√ß√µes em disputas regulat√≥rias',
        probabilidade: 'Baixa',
        severidade: 'Alta',
        mitigacao: 'Logs imut√°veis com assinaturas digitais, WAL (Write-Ahead Logging)',
        capec: 'CAPEC-98, CAPEC-99',
        deteccao: 'Verifica√ß√£o de integridade dos logs atrav√©s de hashes criptogr√°ficos'
      }
    ];

    // Filtrar amea√ßas baseado no tipo de sistema
    switch (systemType) {
      case 'web':
        return baseThreats.filter(t => ['T001', 'T002', 'T004'].includes(t.id));
      case 'api':
        return baseThreats.filter(t => ['T002', 'T003', 'T004'].includes(t.id));
      case 'mobile':
        return baseThreats.filter(t => ['T001', 'T003', 'T005'].includes(t.id));
      default:
        return baseThreats;
    }
  }

  /**
   * Processa resposta da IA e extrai amea√ßas
   */
  static processAIResponse(aiResponse: string, systemType: string): Threat[] {
    try {
      console.log('üîç Processando resposta da IA:', aiResponse.substring(0, 200) + '...');
      let threats: Threat[] = [];

      // Estrat√©gia 1: Tentar parsear diretamente como JSON
      try {
        const directParse = JSON.parse(aiResponse);
        threats = directParse.threats || directParse.ameacas || [];
        console.log('‚úÖ JSON parseado diretamente, threats encontradas:', threats.length);
      } catch (e) {
        console.log('‚ö†Ô∏è Parsing direto falhou, procurando JSON na resposta...');
        
        // Estrat√©gia 2: Procurar JSON dentro de blocos de c√≥digo
        const jsonBlockMatch = aiResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/i);
        if (jsonBlockMatch) {
          try {
            console.log('üîç JSON encontrado em bloco de c√≥digo:', jsonBlockMatch[1].substring(0, 100) + '...');
            const parsed = JSON.parse(jsonBlockMatch[1]);
            threats = parsed.threats || parsed.ameacas || [];
            console.log('‚úÖ JSON extra√≠do de bloco, threats encontradas:', threats.length);
          } catch (parseError) {
            console.log('‚ùå Erro ao parsear JSON do bloco:', parseError);
          }
        } else {
          // Estrat√©gia 3: Procurar JSON solto na resposta
          const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            try {
              console.log('üîç JSON encontrado na resposta:', jsonMatch[0].substring(0, 100) + '...');
              const parsed = JSON.parse(jsonMatch[0]);
              threats = parsed.threats || parsed.ameacas || [];
              console.log('‚úÖ JSON extra√≠do, threats encontradas:', threats.length);
            } catch (parseError) {
              console.log('‚ùå Erro ao parsear JSON solto:', parseError);
            }
          }
        }
      }

      // Estrat√©gia 4: Se n√£o encontrou JSON v√°lido, processar texto natural
      if (threats.length === 0) {
        console.log('üîÑ Tentando extrair amea√ßas de texto natural...');
        threats = this.parseNaturalLanguageThreats(aiResponse, systemType);
        if (threats.length > 0) {
          console.log('‚úÖ Amea√ßas extra√≠das de texto natural:', threats.length);
        }
      }

      if (threats.length === 0) {
        console.log('‚ö†Ô∏è Nenhuma amea√ßa encontrada, usando mock');
        threats = this.getMockThreatsForSystem(systemType);
      }

      console.log('üéØ Gerando relat√≥rio com', threats.length, 'amea√ßas');
      return threats;
    } catch (error) {
      console.error('‚ùå Erro ao processar resposta da IA:', error);
      console.log('üîÑ Usando dados mock como fallback');
      return this.getMockThreatsForSystem(systemType);
    }
  }

  /**
   * Extrai amea√ßas de texto natural
   */
  private static parseNaturalLanguageThreats(text: string, systemType: string): Threat[] {
    const threats: Threat[] = [];
    const sections = text.split(/\n\s*\n/);
    
    sections.forEach((section, index) => {
      const hasThreats = this.THREAT_KEYWORDS.some(keyword => 
        section.toLowerCase().includes(keyword)
      );
      
      if (hasThreats && threats.length < 6) {
        // Determinar categoria STRIDE baseada no conte√∫do real
        let strideCategory = ['T']; // Default
        const detectedCategories: string[] = [];
        
        for (const [stride, keywords] of Object.entries(this.STRIDE_KEYWORDS)) {
          if (keywords.some(keyword => section.toLowerCase().includes(keyword))) {
            detectedCategories.push(stride);
          }
        }
        
        // Usar m√∫ltiplas categorias se detectadas, sen√£o usar default
        if (detectedCategories.length > 0) {
          strideCategory = detectedCategories;
        }
        
        // Extrair CAPEC se mencionado nesta se√ß√£o
        const sectionCapecs = section.match(/CAPEC-\d+/gi) || [];
        const capec = sectionCapecs.length > 0 ? (sectionCapecs[0] || `CAPEC-${Math.floor(Math.random() * 900) + 100}`) : `CAPEC-${Math.floor(Math.random() * 900) + 100}`;
        
        threats.push({
          id: `T${index + 1}`,
          stride: strideCategory,
          categoria: this.extractCategory(section),
          ameaca: this.extractThreat(section),
          descricao: section.substring(0, 200).trim() + (section.length > 200 ? '...' : ''),
          impacto: this.extractImpact(section),
          probabilidade: this.extractProbability(section),
          severidade: this.extractSeverity(section),
          mitigacao: this.extractMitigation(section),
          capec: capec,
          deteccao: this.extractDetection(section)
        });
      }
    });
    
    return threats;
  }

  // M√©todos auxiliares para extra√ß√£o de informa√ß√µes
  private static extractCategory(text: string): string {
    if (/authentication|autentica√ß√£o|login/i.test(text)) return 'Autentica√ß√£o';
    if (/data|dados|integrity|integridade/i.test(text)) return 'Integridade de Dados';
    if (/information|informa√ß√£o|disclosure|exposi√ß√£o/i.test(text)) return 'Exposi√ß√£o de Dados';
    if (/denial|nega√ß√£o|service|servi√ßo/i.test(text)) return 'Nega√ß√£o de Servi√ßo';
    if (/privilege|privil√©gio|elevation|escala√ß√£o/i.test(text)) return 'Escala√ß√£o de Privil√©gios';
    return 'Seguran√ßa Geral';
  }

  private static extractThreat(text: string): string {
    const lines = text.split('\n');
    const firstLine = lines[0]?.trim();
    if (firstLine && firstLine.length > 10 && firstLine.length < 100) {
      return firstLine;
    }
    return 'Amea√ßa identificada na an√°lise';
  }

  private static extractImpact(text: string): string {
    if (/high|alta|elevado/i.test(text)) return 'Alto impacto na seguran√ßa do sistema';
    if (/low|baixo/i.test(text)) return 'Baixo impacto, mas requer aten√ß√£o';
    return 'Impacto moderado na opera√ß√£o do sistema';
  }

  private static extractProbability(text: string): string {
    if (/high|alta|elevada/i.test(text)) return 'Alta';
    if (/low|baixa/i.test(text)) return 'Baixa';
    return 'M√©dia';
  }

  private static extractSeverity(text: string): string {
    if (/critical|cr√≠tica/i.test(text)) return 'Cr√≠tica';
    if (/high|alta/i.test(text)) return 'Alta';
    if (/low|baixa/i.test(text)) return 'Baixa';
    return 'M√©dia';
  }

  private static extractMitigation(text: string): string {
    if (/implement|implementar|configure|configurar/i.test(text)) {
      return 'Implementar controles de seguran√ßa apropriados';
    }
    return 'Implementar medidas de mitiga√ß√£o baseadas nas melhores pr√°ticas de seguran√ßa';
  }

  private static extractDetection(text: string): string {
    return 'Monitoramento de atividades suspeitas';
  }
}
