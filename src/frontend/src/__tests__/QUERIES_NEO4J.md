# üîç Guia de Queries Neo4j para Z4l1nux AI Threat Lab

## üìä **Queries B√°sicas de Visualiza√ß√£o**

### 1. Ver TODOS os documentos com estat√≠sticas
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
RETURN d.name as Documento, 
       d.uploadedAt as DataUpload,
       count(c) as TotalChunks,
       d.size as TamanhoBytes,
       d.hash as HashConteudo
ORDER BY d.uploadedAt DESC
```

### 2. Ver chunks de um documento espec√≠fico (com preview)
```cypher
MATCH (d:Document {name: "capec-stride-mapping.md"})-[:CONTAINS]->(c:Chunk)
RETURN c.index as ChunkIndex,
       substring(c.content, 0, 200) as PreviewConteudo,
       c.size as TamanhoBytes
ORDER BY c.index
LIMIT 10
```

### 3. Buscar documentos por palavra-chave no conte√∫do
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
WHERE c.content CONTAINS "Spoofing" 
   OR c.content CONTAINS "CAPEC-"
   OR c.content CONTAINS "STRIDE"
RETURN d.name as Documento,
       c.index as Chunk,
       substring(c.content, 0, 250) as Preview
LIMIT 15
```

### 4. Estat√≠sticas gerais do RAG
```cypher
MATCH (d:Document)
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
RETURN count(DISTINCT d) as TotalDocumentos,
       count(c) as TotalChunks,
       sum(d.size) as TamanhoTotalBytes,
       avg(c.size) as MediaTamanhoChunk
```

## üîé **Queries para Validar Mapeamento STRIDE-CAPEC**

### 5. Ver CAPECs dispon√≠veis para cada categoria STRIDE
```cypher
MATCH (d:Document {name: "capec-stride-mapping.md"})-[:CONTAINS]->(c:Chunk)
WHERE c.content CONTAINS "##" 
   OR c.content CONTAINS "CAPEC-"
   OR c.content CONTAINS "Spoofing"
   OR c.content CONTAINS "Tampering"
RETURN c.index as ChunkIndex,
       c.content as Conteudo
ORDER BY c.index
LIMIT 20
```

### 6. Buscar CAPECs espec√≠ficos por ID
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
WHERE c.content CONTAINS "CAPEC-113" 
   OR c.content CONTAINS "CAPEC-212"
   OR c.content CONTAINS "CAPEC-590"
RETURN d.name as Documento,
       c.index as Chunk,
       c.content as Detalhes
```

### 7. Ver todas as categorias STRIDE documentadas
```cypher
MATCH (d:Document {name: "capec-stride-mapping.md"})-[:CONTAINS]->(c:Chunk)
WHERE c.content CONTAINS "Information Disclosure"
   OR c.content CONTAINS "Spoofing"
   OR c.content CONTAINS "Tampering"
   OR c.content CONTAINS "Repudiation"
   OR c.content CONTAINS "Denial of Service"
   OR c.content CONTAINS "Elevation of Privilege"
RETURN c.index as Chunk,
       substring(c.content, 0, 300) as Categoria
ORDER BY c.index
```

## üéØ **Queries para Validar Sistema Modelado**

### 8. Ver informa√ß√µes do sistema modelado mais recente
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
WHERE d.name CONTAINS "Sistema_"
RETURN d.name as Sistema,
       d.uploadedAt as DataModelagem,
       count(c) as Chunks,
       substring(d.content, 0, 500) as PreviewSistema
ORDER BY d.uploadedAt DESC
LIMIT 3
```

### 9. Buscar informa√ß√µes t√©cnicas do sistema
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
WHERE d.name CONTAINS "Sistema_"
  AND (c.content CONTAINS "TECNOLOGIAS"
   OR c.content CONTAINS "COMPONENTES"
   OR c.content CONTAINS "DADOS SENS√çVEIS")
RETURN d.name as Sistema,
       c.index as Chunk,
       c.content as InformacoesTecnicas
ORDER BY d.uploadedAt DESC
LIMIT 5
```

## üßπ **Queries de Manuten√ß√£o**

### 10. Deletar um documento espec√≠fico e seus chunks
```cypher
// Deletar um documento espec√≠fico pelo nome exato
MATCH (d:Document {name: "nome-do-documento.md"})
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN "Documento deletado" as Status
```

**Exemplo pr√°tico:**
```cypher
// Deletar documento do SuperMax
MATCH (d:Document {name: "Sistema_SuperMax Retail Management Platform (v3.2.1)_2025-10-01"})
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN "Documento SuperMax deletado" as Status
```

### 10b. Deletar todos os documentos que cont√™m um termo no nome
```cypher
// CUIDADO: Deleta TODOS os documentos cujo nome contenha o termo
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN count(d) as DocumentosDeletados
```

### 10c. Deletar vers√µes antigas de um sistema (manter s√≥ a mais recente)
```cypher
// Deletar todas as vers√µes antigas de um sistema, mantendo apenas a mais recente
MATCH (d:Document)
WHERE d.name CONTAINS "Sistema_Growth Campaigns"
WITH d ORDER BY d.uploadedAt DESC
WITH collect(d) as docs
WITH docs[1..] as oldDocs  // Pega todos exceto o primeiro (mais recente)
UNWIND oldDocs as doc
OPTIONAL MATCH (doc)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, doc
RETURN count(doc) as Vers√µesAntigasDeletadas
```

### 10d. ‚ö†Ô∏è Visualizar o que ser√° deletado ANTES de deletar
```cypher
// SEMPRE execute esta query PRIMEIRO para confirmar o que ser√° deletado!
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
RETURN d.name as Documento,
       d.uploadedAt as DataUpload,
       count(c) as TotalChunks,
       d.size as TamanhoBytes
```

### 11. Identificar documentos duplicados (mesmo nome)
```cypher
MATCH (d:Document)
WITH d.name as NomeDoc, collect(d) as docs, count(d) as total
WHERE total > 1
RETURN NomeDoc, total, [doc IN docs | doc.uploadedAt] as Datas
```

### 12. Limpar documentos antigos (CUIDADO!)
```cypher
// ATEN√á√ÉO: Esta query DELETA dados!
// Deleta vers√µes antigas de documentos duplicados (mant√©m a mais recente)
MATCH (d:Document)
WITH d.name as nome, collect(d) as docs
WHERE size(docs) > 1
WITH nome, docs, [doc IN docs | doc.uploadedAt] as datas
UNWIND docs as doc
WITH nome, doc, datas, max(datas) as dataRecente
WHERE doc.uploadedAt < dataRecente
OPTIONAL MATCH (doc)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, doc
RETURN count(doc) as DocumentosDeletados
```

### 13. Ver tamanho de embeddings (validar vetoriza√ß√£o)
```cypher
MATCH (c:Chunk)
WHERE c.embedding IS NOT NULL
RETURN count(c) as ChunksComEmbedding,
       size(c.embedding) as DimensaoEmbedding
LIMIT 1
```

## üî¨ **Queries Avan√ßadas para Debugging**

### 14. Ver metadata dos chunks
```cypher
MATCH (d:Document)-[:CONTAINS]->(c:Chunk)
RETURN d.name as Documento,
       c.index as Chunk,
       c.metadata as Metadata
LIMIT 10
```

### 15. Verificar documentos sem chunks (problema!)
```cypher
MATCH (d:Document)
WHERE NOT (d)-[:CONTAINS]->(:Chunk)
RETURN d.name as DocumentoSemChunks,
       d.uploadedAt as Data,
       d.size as Tamanho
```

### 16. Ver estrutura completa do grafo
```cypher
CALL db.schema.visualization()
```

### 17. Busca vetorial manual (simular RAG)
```cypher
// Esta query N√ÉO funciona diretamente no Neo4j Browser
// Use o endpoint /api/search do backend para busca vetorial real
MATCH (c:Chunk)
WHERE c.content CONTAINS "threat modeling"
RETURN c.documentId as Documento,
       c.index as Chunk,
       substring(c.content, 0, 200) as Preview
LIMIT 10
```

## üìù **Como Executar no Neo4j Browser**

1. Acesse: **http://localhost:7474**
2. Conecte com:
   - **Bolt URL**: `bolt://localhost:7687`
   - **Usu√°rio**: `neo4j`
   - **Senha**: [use a senha configurada no seu .env.local]
3. Cole a query no campo de texto
4. Pressione **Ctrl+Enter** ou clique no bot√£o ‚ñ∂Ô∏è

## üéØ **Queries Essenciais para Valida√ß√£o RAG**

### ‚úÖ Verificar se mapeamento STRIDE-CAPEC est√° carregado:
```cypher
MATCH (d:Document {name: "capec-stride-mapping.md"})-[:CONTAINS]->(c:Chunk)
RETURN count(c) as TotalChunks
```
**Esperado**: 40 chunks

### ‚úÖ Verificar se sistema foi processado:
```cypher
MATCH (d:Document)
WHERE d.name CONTAINS "Sistema_"
RETURN d.name as Sistema, d.uploadedAt as Data
ORDER BY d.uploadedAt DESC
LIMIT 3
```

### ‚úÖ Validar embeddings (vetoriza√ß√£o):
```cypher
MATCH (c:Chunk)
WHERE c.embedding IS NOT NULL
RETURN count(c) as ChunksVetorizados,
       size(head(collect(c.embedding))) as DimensaoVetor
```
**Esperado**: DimensaoVetor = 768 (Gemini gemini-embedding-001)

---

## üîó **Endpoints Backend para Busca RAG**

Enquanto o Neo4j Browser permite visualizar dados, a **busca sem√¢ntica vetorial** deve ser feita via backend:

```bash
# Busca RAG com contexto
curl -X POST http://localhost:3001/api/search/context \
  -H "Content-Type: application/json" \
  -d '{"query": "threat modeling Spoofing attacks", "limit": 5}'

# Estat√≠sticas do sistema
curl http://localhost:3001/api/statistics
```

---

## üéØ **Exemplos Pr√°ticos de Limpeza**

### üóëÔ∏è **Limpar documentos de teste do SuperMax:**
```cypher
// 1. Ver o que ser√° deletado
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
RETURN d.name as Documento, 
       d.uploadedAt as Data,
       count(c) as Chunks
ORDER BY d.uploadedAt DESC

// 2. Confirmar e deletar
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN "SuperMax removido" as Status
```

### üîÑ **Manter apenas a vers√£o mais recente de cada sistema:**
```cypher
// Para Growth Campaigns - manter s√≥ a √∫ltima vers√£o
MATCH (d:Document)
WHERE d.name CONTAINS "Sistema_Growth Campaigns"
WITH d ORDER BY d.uploadedAt DESC
WITH collect(d) as docs
WITH docs[1..] as oldDocs
UNWIND oldDocs as doc
OPTIONAL MATCH (doc)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, doc
RETURN count(doc) as Vers√µesAntigasDeletadas
```

### üßπ **Limpeza completa (resetar TODA a base):**
```cypher
// ‚ö†Ô∏è ATEN√á√ÉO: Remove TODOS os documentos e chunks da base!
// Use apenas se tiver certeza absoluta
MATCH (d:Document)
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN count(d) as DocumentosDeletados
```

### üìä **Listar todos os sistemas processados:**
```cypher
MATCH (d:Document)
WHERE d.name STARTS WITH "Sistema_"
RETURN d.name as Sistema, 
       d.uploadedAt as Processado,
       count{(d)-[:CONTAINS]->(:Chunk)} as Chunks
ORDER BY d.uploadedAt DESC
```

### üîç **Deletar por ID espec√≠fico:**
```cypher
// √ötil quando voc√™ sabe o ID exato do documento
MATCH (d:Document {id: "c8600e0ac3fb6b247a522154657e4248"})
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN "Documento deletado por ID" as Status
```

### üéØ **Deletar documentos mais antigos que uma data:**
```cypher
// Deletar documentos anteriores a uma data espec√≠fica
MATCH (d:Document)
WHERE d.uploadedAt < "2025-10-01"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
RETURN count(d) as DocumentosAntigosDeletados
```

---

## ‚ö†Ô∏è **Dicas de Seguran√ßa para Dele√ß√£o**

‚úÖ **SEMPRE visualize antes de deletar** - Use a query 10d  
‚úÖ **Use nomes exatos** quando poss√≠vel - `{name: "exato.md"}`  
‚úÖ **Teste com RETURN primeiro** - Troque DELETE por RETURN para ver o que pegaria  
‚úÖ **Fa√ßa backup** - Se poss√≠vel, exporte antes de opera√ß√µes destrutivas  
‚ùå **Cuidado com CONTAINS** - Pode pegar mais documentos que o esperado  
‚ùå **N√£o use DETACH DELETE sem MATCH** - Pode deletar tudo!

---

## üîÑ **Workflow Recomendado de Limpeza**

1. **üìã Listar** - Veja o que existe
```cypher
MATCH (d:Document)
RETURN d.name, d.uploadedAt, count{(d)-[:CONTAINS]->(:Chunk)} as Chunks
ORDER BY d.uploadedAt DESC
```

2. **üîç Visualizar** - Veja o que ser√° deletado
```cypher
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
RETURN d.name, count{(d)-[:CONTAINS]->(:Chunk)} as Chunks
```

3. **üóëÔ∏è Deletar** - Execute a dele√ß√£o
```cypher
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
OPTIONAL MATCH (d)-[:CONTAINS]->(c:Chunk)
DETACH DELETE c, d
```

4. **‚úÖ Confirmar** - Verifique se foi deletado
```cypher
MATCH (d:Document)
WHERE d.name CONTAINS "SuperMax"
RETURN count(d) as Restantes  // Deve retornar 0
```

